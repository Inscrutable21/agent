import { NextResponse } from 'next/server'
import { prisma } from '../../../../../../lib/prisma'

export async function GET() {
  try {
    // Get stats from database - persists after logout/login
    const [
      totalTestCases,
      requirementBasedTests,
      avgRiskScore,
      lastGenerated
    ] = await Promise.all([
      // Count total test cases generated by AI
      prisma.qATestCase.count({
        where: {
          generatedBy: 'ai'
        }
      }),
      
      // Count requirement-based tests by checking metadata
      prisma.qATestCase.findMany({
        where: {
          generatedBy: 'ai',
          metadata: {
            not: null
          }
        },
        select: {
          metadata: true
        }
      }).then(testCases => {
        return testCases.filter(tc => {
          try {
            const metadata = typeof tc.metadata === 'string' 
              ? JSON.parse(tc.metadata) 
              : tc.metadata
            return metadata?.requirementBased === true
          } catch {
            return false
          }
        }).length
      }),
      
      // Calculate average risk score (prefer top-level field, fallback to metadata)
      prisma.qATestCase.findMany({
        where: { generatedBy: 'ai' },
        select: { riskScore: true, metadata: true }
      }).then(testCases => {
        const scores = testCases
          .map(tc => {
            if (typeof tc.riskScore === 'number' && !Number.isNaN(tc.riskScore)) {
              return tc.riskScore
            }
            try {
              const meta = typeof tc.metadata === 'string' ? JSON.parse(tc.metadata) : tc.metadata
              const m = meta?.riskScore ?? meta?.risk
              return typeof m === 'number' ? m : 0
            } catch {
              return 0
            }
          })
          .filter(n => n > 0)

        return scores.length
          ? (scores.reduce((a, b) => a + b, 0) / scores.length)
          : 0
      }),
      
      // Get last generated timestamp
      prisma.qATestCase.findFirst({
        where: {
          generatedBy: 'ai'
        },
        orderBy: {
          createdAt: 'desc'
        },
        select: {
          createdAt: true
        }
      })
    ])

    // Calculate requirements estimate (unique components or requirement-based tests)
    const totalRequirements = Math.max(
      requirementBasedTests,
      Math.ceil(totalTestCases / 8) // Estimate: ~8 tests per requirement
    )

    return NextResponse.json({
      success: true,
      stats: {
        totalRequirements,
        totalTestCases,
        avgRiskScore: Number((avgRiskScore || 0).toFixed(1)),
        lastGenerated: lastGenerated?.createdAt || null
      }
    })
    
  } catch (error) {
    console.error('Stats API error:', error)
    return NextResponse.json(
      { error: 'Failed to load stats', details: error.message },
      { status: 500 }
    )
  }
}